// Plugin Docusaurus : Génère un fichier docsMetadata.json à partir des frontmatters des fichiers Markdown du dossier docs/01-cours

const fs = require("fs");
const path = require("path");

/**
 * Extrait le frontmatter d'un contenu Markdown
 * @param {string} content
 * @returns {Object} frontmatter
 */
function extractFrontmatter(content) {
  const match = content.match(/^---([\s\S]*?)---/);
  if (!match) return null;
  const frontmatter = {};
  match[1].split("\n").forEach((line) => {
    const [key, ...rest] = line.split(":");
    if (key && rest.length) {
      frontmatter[key.trim()] = rest.join(":").trim();
    }
  });
  return frontmatter;
}

/**
 * Retourne le chemin absolu du fichier docsMetadata.json dans static/
 * @returns {string}
 */
function getStaticMetadataPath() {
  return path.resolve(__dirname, "../../static/docsMetadata.json");
}

/**
 * Extrait les métadonnées (frontmatter) de tous les fichiers .md d'un dossier
 * @param {Object} params
 * @param {string} params.docsDir - Chemin du dossier contenant les fichiers Markdown
 * @returns {Array<Object>} Tableau d'objets métadonnées
 */
function getAllDocsMetadata({ docsDir }) {
  const docs = [];
  const files = fs.readdirSync(docsDir);
  for (const file of files) {
    if (!file.endsWith(".md")) continue;
    const docPath = path.join(docsDir, file);
    const content = fs.readFileSync(docPath, "utf-8");
    const frontmatter = extractFrontmatter(content);
    if (!frontmatter) continue;
    docs.push({
      id: file.replace(/\.md$/, ""),
      ...frontmatter,
    });
  }
  return docs;
}

/**
 * Extrait tous les objets avec tous les champs présents dans item pour les entrées de type 'doc',
 * et {id} pour 'autogenerated'.
 * @param {Array} items
 * @returns {Array<Object>}
 */
function extractAllDocEntries(items) {
  let entries = [];
  for (const item of items) {
    if (item.type === "doc" && item.id) {
      // Inclure tous les champs de l'item (shallow copy)
      entries.push({ ...item });
    } else if (item.type === "category" && Array.isArray(item.items)) {
      entries = entries.concat(extractAllDocEntries(item.items));
    } else if (item.type === "autogenerated" && item.dirName) {
      const dirPath = path.resolve(__dirname, `../../docs/${item.dirName}`);
      if (fs.existsSync(dirPath)) {
        const files = fs.readdirSync(dirPath);
        files.forEach((file) => {
          if (file.endsWith(".md")) {
            entries.push({ id: file.replace(/\.md$/, "") });
          }
        });
      }
    }
  }
  return entries;
}

/**
 * Génère le fichier sidebarDocs.js à partir de sidebars.js
 */
function generateSidebarDocs() {
  const sidebarPath = path.resolve(__dirname, "../../sidebars.js");
  const outputPath = path.resolve(
    __dirname,
    "../../src/components/MainDocsGrid/sidebarDocs.js"
  );
  const sidebars = require(sidebarPath);
  // Ne prendre que la section 'docs'
  let allEntries = [];
  if (Array.isArray(sidebars.docs)) {
    allEntries = extractAllDocEntries(sidebars.docs);
  }
  const content =
    "// Ce fichier est généré automatiquement à partir de sidebars.js\n" +
    "export default " +
    JSON.stringify(allEntries, null, 2) +
    ";\n";
  fs.writeFileSync(outputPath, content);
}

/**
 * Plugin Docusaurus pour exposer les métadonnées des documents
 */
module.exports = function pluginDocsMetadata(context, options) {
  return {
    name: "docusaurus-plugin-docs-metadata",
    /**
     * Chargement des métadonnées à partir des fichiers Markdown
     */
    async loadContent() {
      const docsDir = path.resolve(__dirname, "../../docs/01-cours");
      return getAllDocsMetadata({ docsDir });
    },
    /**
     * Génère le fichier docsMetadata.json dans static/ pour qu'il soit déployé
     */
    async contentLoaded({ content }) {
      fs.writeFileSync(
        getStaticMetadataPath(),
        JSON.stringify(content, null, 2)
      );
      generateSidebarDocs(); // Génère sidebarDocs.js à chaque build
    },
  };
};
